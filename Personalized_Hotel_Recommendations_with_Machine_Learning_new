{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "id": "VDspGRo_rTPu"
   },
   "outputs": [],
   "source": [
    "import pandas as pd\n",
    "import numpy as np\n",
    "import matplotlib.pyplot as plt\n",
    "import seaborn as sns\n",
    "import geopandas as gpd\n",
    "import folium\n",
    "import plotly\n",
    "import plotly.offline as py\n",
    "import plotly.graph_objs as go"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/",
     "height": 429
    },
    "id": "7AwXCKcLroRL",
    "outputId": "b914329a-cf5c-4a18-e184-e9636e00debf"
   },
   "outputs": [],
   "source": [
    "resturant_data = pd.read_csv('/content/sample_data/resturant (1).csv')\n",
    "resturant_data.head()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "8WxRYOSg3PDc"
   },
   "source": [
    "Check the dimention of the dataset"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/"
    },
    "id": "k0huiPPC3Mks",
    "outputId": "3096ef9c-703e-44b6-a714-4ffc8a3a00c4"
   },
   "outputs": [],
   "source": [
    "resturant_data.shape"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/"
    },
    "id": "m7TFF13M3VoJ",
    "outputId": "4093df3a-68de-4282-b5e8-d62c9887ac49"
   },
   "outputs": [],
   "source": [
    "len(resturant_data)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/"
    },
    "id": "jBoP7XyVr4dS",
    "outputId": "2d4f86db-06b2-4da3-8f30-b58d40b0fed4"
   },
   "outputs": [],
   "source": [
    "resturant_data.info()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "vdzUwJzZ3Zsi"
   },
   "source": [
    "Remove unwanted columns\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "id": "sy3D637JsTTe"
   },
   "outputs": [],
   "source": [
    "resturant_data = resturant_data.drop(\n",
    "    [  'establishmentTypes/items/0/id', 'establishmentTypes/items/0/tag/localizedName', 'establishmentTypes/items/1/id', 'establishmentTypes/items/1/tag/localizedName', 'establishmentTypes/items/2/id', 'establishmentTypes/items/2/tag/localizedName',\n",
    "     'isAdsPreview', 'isSponsoredListing', 'location/distance','location/geoPoint','locationId','menu/hasProvider','menu/menuUrl','offers/hasDelivery','offers/hasReservation','offers/restaurantSpecialOffer','offers/slot1Offer','offers/slot2Offer',\n",
    "       'openHours/openStatusText','priceTypes/items/0/secondaryName','reviewSnippetsV2/reviews/0/review/absoluteUrl','reviewSnippetsV2/reviews/0/review/status','reviewSnippetsV2/reviews/0/review/url','reviewSnippetsV2/reviews/0/seoContentType',\n",
    "       'reviewSnippetsV2/reviews/1/review','reviewSnippetsV2/reviews/1/review/absoluteUrl','reviewSnippetsV2/reviews/1/review/status','reviewSnippetsV2/reviews/1/review/url',\n",
    "       'reviewSnippetsV2/reviews/1/seoContentType','sponsoredListingData','storyboardStatus','taLocation/contact/streetAddress/country','taLocation/contact/streetAddress/postalCode',\n",
    "       'taLocation/hierarchy/parentGeoId', 'taLocation/names/parentGeo', 'thumbnail', 'thumbnail/photo/photoSizeDynamic/maxHeight', 'thumbnail/photo/photoSizeDynamic/maxWidth', 'thumbnail/photo/photoSizeDynamic/urlTemplate',\n",
    "       'travelerAwards'],axis=1)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "8TBJEga63d2D"
   },
   "source": [
    "Rename the columns"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "id": "dN1L35V8K9lJ"
   },
   "outputs": [],
   "source": [
    "resturant_data.columns = ['cuisine1', 'cuisine2', 'cuisine3', 'cuisine4', 'cuisine5', 'cuisine6', 'cuisine7', 'url', 'isLocalChef', 'isPremium', 'latitude', 'longitude', 'name', 'isOpen', 'Review1', 'Review2', 'reviewCount', 'rating', 'address', 'telephone', 'awardType', 'year']"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "id": "7hqClA_QL3HI"
   },
   "outputs": [],
   "source": [
    "resturant_data['Review'] = resturant_data[['Review1', 'Review2']].fillna('').agg(' '.join, axis=1)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "id": "_g-n1HX6HYHY"
   },
   "outputs": [],
   "source": [
    "resturant_data['year'] = resturant_data['year'].astype('Int64')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/",
     "height": 637
    },
    "id": "uQuRmT3vr8xn",
    "outputId": "3700fdcf-4ea7-4608-a574-5e7ab09d1a7b"
   },
   "outputs": [],
   "source": [
    "resturant_data.head()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "80jzwKsh3xpD"
   },
   "source": [
    "Convert object value to numeric"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/"
    },
    "id": "jHJywpSyDpSW",
    "outputId": "78f3d7cd-50da-45e0-b39a-630f22ab1c8c"
   },
   "outputs": [],
   "source": [
    " resturant_data['isLocalChef'] = resturant_data['isLocalChef'].replace({True: 1, False: 0})\n",
    " resturant_data['isPremium'] = resturant_data['isPremium'].replace({True: 1, False: 0})"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/"
    },
    "id": "F_3o1AhCEXO9",
    "outputId": "8b1f6ce5-fd4f-4d15-8b09-06eba38b6411"
   },
   "outputs": [],
   "source": [
    "resturant_data['isOpen'].unique()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/",
     "height": 620
    },
    "id": "CFNKncAnEoBV",
    "outputId": "5af513ba-a212-4d5b-dcdf-5dd5d6cff7bc"
   },
   "outputs": [],
   "source": [
    "#Convert IsOpen column value to numeric. Original values are 'OPEN', 'CLOSED', 'CLOSING', nan\n",
    "mapping = {'OPEN': 1, 'CLOSED': 0, 'CLOSING': 0,'OPENING': 1, np.nan: -1}\n",
    "resturant_data['isOpen'] = resturant_data['isOpen'].map(mapping)\n",
    "resturant_data['isOpen'] = resturant_data['isOpen'].astype(int)\n",
    "resturant_data.head()\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "_2Iw3Tmw2X2A"
   },
   "source": [
    "Remove the rows has duplicated name"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "id": "eHu6Rkmk2XJp"
   },
   "outputs": [],
   "source": [
    "resturant_data.drop_duplicates(subset=['name'], keep='first',inplace=True)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/"
    },
    "id": "OoC44_IQIDPq",
    "outputId": "3c4e0047-adfc-4262-81e5-e73a2feb2823"
   },
   "outputs": [],
   "source": [
    "resturant_data.shape"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "id": "WVOf2m4W-2UL"
   },
   "outputs": [],
   "source": [
    "import re\n",
    "import string"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/",
     "height": 241
    },
    "id": "AtR9UbID-4hP",
    "outputId": "492618b6-47b8-43c4-b8d3-a4490f07e950"
   },
   "outputs": [],
   "source": [
    "resturant_data['Review'].head()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "id": "ow928o9VM1x-"
   },
   "outputs": [],
   "source": [
    "#Convert upper case to lower case\n",
    "resturant_data['Review'] = resturant_data['Review'].apply(lambda x: \" \".join(x.lower() for x in x.split()))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "id": "BfKx4oJeM-aJ"
   },
   "outputs": [],
   "source": [
    "#remove links\n",
    "resturant_data['Review'] = resturant_data['Review'].apply(lambda x: \" \".join(re.sub(r'^https?:\\/\\/.*[\\r\\n]*', '', x, flags=re.MULTILINE) for x in x.split()))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/",
     "height": 36
    },
    "id": "1MIGLJ8aNKJj",
    "outputId": "c5f96651-1d1a-4343-a838-e43dfd8f42e2"
   },
   "outputs": [],
   "source": [
    "string.punctuation"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "id": "fdONURYCNQ7i"
   },
   "outputs": [],
   "source": [
    "#Remove Punctuations\n",
    "def remove_punctuations(Review):\n",
    "    for punctuation in string.punctuation:\n",
    "        Review = Review.replace(punctuation, '')\n",
    "    return Review\n",
    "\n",
    "resturant_data['Review'] = resturant_data['Review'].apply(remove_punctuations)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "id": "Md6irirmNi3G"
   },
   "outputs": [],
   "source": [
    "#Remove Numbers\n",
    "resturant_data['Review'] = resturant_data['Review'].str.replace('\\d+', '', regex=True)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/",
     "height": 241
    },
    "id": "T8SkM2ddNuXg",
    "outputId": "bbf12b2d-323d-438c-d855-16625af75f27"
   },
   "outputs": [],
   "source": [
    "# Remove emojis\n",
    "resturant_data['Review'] = resturant_data['Review'].str.replace('[^\\x00-\\x7F]+', '', regex=True)\n",
    "resturant_data['Review'].head()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/"
    },
    "id": "S21sJlF-OE69",
    "outputId": "08a2f144-ed4c-4bd0-a09d-f532f3e44b87"
   },
   "outputs": [],
   "source": [
    "import nltk\n",
    "\n",
    "from nltk.corpus import stopwords\n",
    "from nltk.stem import WordNetLemmatizer\n",
    "\n",
    "nltk.download('stopwords')\n",
    "nltk.download('punkt')\n",
    "nltk.download('wordnet')\n",
    "\n",
    "stopwords = nltk.corpus.stopwords.words('english')\n",
    "lemmatizer = WordNetLemmatizer()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/",
     "height": 241
    },
    "id": "ijlO93OXOG9e",
    "outputId": "40cee30c-de27-476f-cd6e-8aa130e230f6"
   },
   "outputs": [],
   "source": [
    "resturant_data['Review'] = resturant_data['Review'].apply(lambda x: \" \".join(x for x in x.split() if x not in stopwords))\n",
    "resturant_data['Review'].head()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "id": "Hhjk8xpQORdm"
   },
   "outputs": [],
   "source": [
    "#Stemming\n",
    "from nltk.stem import PorterStemmer\n",
    "ps = PorterStemmer()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "id": "Y49U86coOVDI"
   },
   "outputs": [],
   "source": [
    "resturant_data['Review'] = resturant_data['Review'].apply(lambda x: \" \".join([ps.stem(x) for word in x.split()]))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "id": "ImvopvxVOdDw"
   },
   "outputs": [],
   "source": [
    "from collections import Counter\n",
    "vocab = Counter()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/"
    },
    "id": "D71H0YkQOeAC",
    "outputId": "305729f9-9515-4b30-bd76-7321728ea0d4"
   },
   "outputs": [],
   "source": [
    "vocab"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/"
    },
    "id": "pJ-y-zwgOftU",
    "outputId": "4b6f45ec-7821-446a-fad2-3d2bb3cdbf5a"
   },
   "outputs": [],
   "source": [
    "for sentence in resturant_data['Review']:\n",
    "  vocab.update(sentence.split())\n",
    "\n",
    "len(vocab)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "id": "jPLdUPTDOyOa"
   },
   "outputs": [],
   "source": [
    "tokens = [key for key in vocab if vocab[key] >= 10]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/"
    },
    "id": "c6TIqXPiO5_g",
    "outputId": "06db44ef-0c6b-4a34-b794-db8c8d5d6656"
   },
   "outputs": [],
   "source": [
    "tokens"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "id": "JPhyv8G-O7Wi"
   },
   "outputs": [],
   "source": [
    "x = resturant_data['Review']\n",
    "y = resturant_data['rating']"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "id": "sRRzzOCIP2E8"
   },
   "outputs": [],
   "source": [
    "from sklearn.model_selection import train_test_split\n",
    "x_train, x_test, y_train, y_test = train_test_split(x, y, test_size=0.2, random_state=42)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/",
     "height": 458
    },
    "id": "6iwe1KRpP7B6",
    "outputId": "dbd3d414-efb2-4ef9-fd23-23e553678806"
   },
   "outputs": [],
   "source": [
    "x_train"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/",
     "height": 458
    },
    "id": "4TXUYv3FP-A1",
    "outputId": "7fe6da98-ef0f-4673-a5a7-6f869f14183b"
   },
   "outputs": [],
   "source": [
    "x_test"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/",
     "height": 458
    },
    "id": "4wAoYpvKQAgY",
    "outputId": "859464c9-fb4a-400f-c4d1-a7ec6df1d204"
   },
   "outputs": [],
   "source": [
    "y_train"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/",
     "height": 458
    },
    "id": "RIv2S8LQQDvl",
    "outputId": "a9dca60c-cfaf-4841-9c5b-06601d85da36"
   },
   "outputs": [],
   "source": [
    "y_test"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "id": "3b0PDNh4QG-o"
   },
   "outputs": [],
   "source": [
    "#Vectorization\n",
    "def vectorizer(ds, vocabulary):\n",
    "  vectorized_lst = []\n",
    "\n",
    "  for sentence in ds:\n",
    "    sentence_lst = np.zeros(len(vocabulary))\n",
    "\n",
    "    for i in range(len(vocabulary)):\n",
    "      if vocabulary[i] in sentence.split():\n",
    "        sentence_lst[i] += 1\n",
    "\n",
    "    vectorized_lst.append(sentence_lst)\n",
    "\n",
    "  vectorized_lst_new = np.asarray(vectorized_lst, dtype = np.float32)\n",
    "\n",
    "  return vectorized_lst_new"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "id": "jqZPU10jQP6j"
   },
   "outputs": [],
   "source": [
    "vectorized_x_train = vectorizer(x_train, tokens)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "id": "7IctIuqKRyfG"
   },
   "outputs": [],
   "source": [
    "vectorized_x_test = vectorizer(x_test, tokens)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/",
     "height": 962
    },
    "id": "IzLxSvxjRziW",
    "outputId": "6a7699bc-ce06-49f2-8121-4daa3e77fa9f"
   },
   "outputs": [],
   "source": [
    "y_train.value_counts()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/",
     "height": 406
    },
    "id": "kpSAQtFXR8FS",
    "outputId": "3f4d4ad8-85e0-46c9-a159-f73918924b21"
   },
   "outputs": [],
   "source": [
    "# Exclude -1 ratings for this visualization\n",
    "valid_ratings = y_train[y_train != -1]\n",
    "\n",
    "# Categorize ratings\n",
    "positive_count = valid_ratings[valid_ratings >= 4].shape[0]\n",
    "neutral_count = valid_ratings[valid_ratings == 3].shape[0]\n",
    "negative_count = valid_ratings[valid_ratings <= 2].shape[0]\n",
    "\n",
    "counts = [positive_count, neutral_count, negative_count]\n",
    "labels = [\"Positive\", \"Neutral\", \"Negative\"]\n",
    "\n",
    "plt.pie(np.array(counts), labels=labels, autopct='%1.1f%%')\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "dSiAEpkUSCbs"
   },
   "source": [
    "Handle Imbalanced Dataset"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/"
    },
    "id": "7Fu63SPmSAkq",
    "outputId": "8a466664-f8e6-4afa-bb83-5092a4afe438"
   },
   "outputs": [],
   "source": [
    "from sklearn.linear_model import LinearRegression\n",
    "from sklearn.utils.class_weight import compute_sample_weight\n",
    "import numpy as np\n",
    "\n",
    "# Calculate sample weights based on the inverse frequency of ratings\n",
    "# We'll use the unique values in y_train as \"classes\" for weighting purposes\n",
    "# Exclude -1 ratings for weight calculation\n",
    "valid_y_train = y_train[y_train != -1]\n",
    "valid_x_train = vectorized_x_train[y_train != -1]\n",
    "\n",
    "if len(valid_y_train) > 0:\n",
    "    sample_weights = compute_sample_weight(\n",
    "        class_weight='balanced',\n",
    "        y=valid_y_train\n",
    "    )\n",
    "\n",
    "    # Initialize and train a Linear Regression model with sample weights\n",
    "    model = LinearRegression()\n",
    "    model.fit(valid_x_train, valid_y_train, sample_weight=sample_weights)\n",
    "\n",
    "    print(\"Model trained with sample weights.\")\n",
    "else:\n",
    "    print(\"No valid ratings in y_train to train the model.\")\n",
    "\n",
    "# Note: You would then evaluate this model using appropriate regression metrics."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/",
     "height": 962
    },
    "id": "8kLmIUKqTKmk",
    "outputId": "0b852f63-61b1-4934-c49c-3328976e33f8"
   },
   "outputs": [],
   "source": [
    "y_train.value_counts()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/"
    },
    "id": "jCwRXxOGU06p",
    "outputId": "5b56467d-a6c1-4461-a4ff-7ed2dcdc1df9"
   },
   "outputs": [],
   "source": [
    "# Categorize ratings into discrete classes\n",
    "# Exclude -1 ratings before categorizing\n",
    "y_train_categorized = y_train[y_train != -1].apply(lambda rating: 'Positive' if rating >= 4 else ('Neutral' if rating == 3 else 'Negative'))\n",
    "y_test_categorized = y_test[y_test != -1].apply(lambda rating: 'Positive' if rating >= 4 else ('Neutral' if rating == 3 else 'Negative'))\n",
    "\n",
    "# Align x_train and x_test with the filtered y_train_categorized and y_test_categorized\n",
    "x_train_categorized = vectorized_x_train[y_train != -1]\n",
    "x_test_categorized = vectorized_x_test[y_test != -1]\n",
    "\n",
    "print(\"Training data shape after categorization:\", x_train_categorized.shape, y_train_categorized.shape)\n",
    "print(\"Testing data shape after categorization:\", x_test_categorized.shape, y_test_categorized.shape)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "eAo8x-vEUWyp"
   },
   "source": [
    "# Model Training and Evolution"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "id": "j_K6aJGmUYRq"
   },
   "outputs": [],
   "source": [
    "from sklearn.linear_model import LogisticRegression\n",
    "from sklearn.naive_bayes import MultinomialNB\n",
    "from sklearn.tree import DecisionTreeClassifier\n",
    "from sklearn.ensemble import RandomForestClassifier\n",
    "from sklearn.svm import SVC"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "id": "omvfmX63Ubws"
   },
   "outputs": [],
   "source": [
    "from sklearn.metrics import accuracy_score, f1_score, precision_score, recall_score\n",
    "\n",
    "def training_scores(y_act,y_pred):\n",
    "  acc = round(accuracy_score(y_act,y_pred),3)\n",
    "  pr = round(precision_score(y_act,y_pred,average='weighted'),3)\n",
    "  rec = round(recall_score(y_act,y_pred,average='weighted'),3)\n",
    "  f1 = round(f1_score(y_act,y_pred,average='weighted'),3)\n",
    "  print(f'Training Scores:\\nAccuracy: {acc}\\nPrecision: {pr}\\nRecall: {rec}\\nF1 Score: {f1}')\n",
    "\n",
    "def validation_scores(y_act,y_pred):\n",
    "  acc = round(accuracy_score(y_act,y_pred),3)\n",
    "  pr = round(precision_score(y_act,y_pred,average='weighted'),3)\n",
    "  rec = round(recall_score(y_act,y_pred,average='weighted'),3)\n",
    "  f1 = round(f1_score(y_act,y_pred,average='weighted'),3)\n",
    "  print(f'Testing Scores:\\nAccuracy: {acc}\\nPrecision: {pr}\\nRecall: {rec}\\nF1 Score: {f1}')"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "b1VBTZH6Ufjd"
   },
   "source": [
    "Logistic Regression"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/"
    },
    "id": "wVvl5-PpUeD0",
    "outputId": "3693bef3-7912-4954-899a-66cb48dbc97b"
   },
   "outputs": [],
   "source": [
    "lr = LogisticRegression(class_weight='balanced')\n",
    "lr.fit(x_train_categorized, y_train_categorized)\n",
    "\n",
    "y_train_pred = lr.predict(x_train_categorized)\n",
    "\n",
    "training_scores(y_train_categorized,y_train_pred)\n",
    "\n",
    "print()\n",
    "\n",
    "y_test_pred = lr.predict(x_test_categorized)\n",
    "\n",
    "validation_scores(y_test_categorized,y_test_pred)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "jxLPODPfVVoB"
   },
   "source": [
    "Naive Bayes"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/"
    },
    "id": "NRJwf-1VU9EG",
    "outputId": "d0c3dcea-88e6-4857-fa8e-902c85c8eccb"
   },
   "outputs": [],
   "source": [
    "mnb = MultinomialNB()\n",
    "mnb.fit(x_train_categorized, y_train_categorized)\n",
    "\n",
    "y_train_pred = mnb.predict(x_train_categorized)\n",
    "\n",
    "training_scores(y_train_categorized,y_train_pred)\n",
    "\n",
    "print()\n",
    "\n",
    "y_test_pred = mnb.predict(x_test_categorized)\n",
    "\n",
    "validation_scores(y_test_categorized,y_test_pred)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "9AWKSpVTVjxH"
   },
   "source": [
    "Decision Tree"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/"
    },
    "id": "YeEuY6oCVYEs",
    "outputId": "580576cd-056f-481c-fa8c-4b3043a93112"
   },
   "outputs": [],
   "source": [
    "dt = DecisionTreeClassifier()\n",
    "dt.fit(x_train_categorized, y_train_categorized)\n",
    "\n",
    "y_train_pred = dt.predict(x_train_categorized)\n",
    "\n",
    "training_scores(y_train_categorized,y_train_pred)\n",
    "\n",
    "print()\n",
    "\n",
    "y_test_pred = dt.predict(x_test_categorized)\n",
    "\n",
    "validation_scores(y_test_categorized,y_test_pred)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "r4N0btQoV49X"
   },
   "source": [
    "Random Forest"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/"
    },
    "id": "sS5vSU2ZVtAn",
    "outputId": "7d45f60e-5021-42dd-d0a5-b725e04b2c35"
   },
   "outputs": [],
   "source": [
    "rf = RandomForestClassifier()\n",
    "rf.fit(x_train_categorized, y_train_categorized)\n",
    "\n",
    "y_train_pred = rf.predict(x_train_categorized)\n",
    "\n",
    "training_scores(y_train_categorized,y_train_pred)\n",
    "\n",
    "print()\n",
    "\n",
    "y_test_pred = rf.predict(x_test_categorized)\n",
    "\n",
    "validation_scores(y_test_categorized,y_test_pred)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "uvDzZAPgdgst"
   },
   "source": [
    "Support Vector Machine"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/"
    },
    "id": "RZpmm0ymV88i",
    "outputId": "ab7eb95b-5cd8-4822-cfa6-74a4e8798fc3"
   },
   "outputs": [],
   "source": [
    "svm = SVC()\n",
    "svm.fit(x_train_categorized, y_train_categorized)\n",
    "\n",
    "y_train_pred = svm.predict(x_train_categorized)\n",
    "\n",
    "training_scores(y_train_categorized,y_train_pred)\n",
    "\n",
    "print()\n",
    "\n",
    "y_test_pred = svm.predict(x_test_categorized)\n",
    "\n",
    "validation_scores(y_test_categorized,y_test_pred)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "mvR8a7eh4GDz"
   },
   "source": [
    "Plot the Count of the rating"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/",
     "height": 839
    },
    "id": "qZa4WJpguKIm",
    "outputId": "e69143b3-4033-4214-93a7-542d4705cc1c"
   },
   "outputs": [],
   "source": [
    "plt.figure(figsize=(10, 8))\n",
    "sns.countplot(x='rating', data=resturant_data, palette='viridis')\n",
    "plt.title('Distribution of Restaurant Ratings')\n",
    "plt.xlabel('Rating')\n",
    "plt.ylabel('Count')\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "Jy_b_nTL1xHH"
   },
   "source": [
    "Top 20 resturant by rating"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/",
     "height": 486
    },
    "id": "x0vA2-RDI-Sp",
    "outputId": "d7cb7aad-37f1-4683-e5d7-34c056ba0273"
   },
   "outputs": [],
   "source": [
    "top_restaurants = resturant_data.sort_values(by = ['rating', 'reviewCount'], ascending = False)[:20]\n",
    "top_restaurants.head()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/",
     "height": 817
    },
    "id": "9svgTksrL6lK",
    "outputId": "38907f36-9e11-4821-a366-99e658c2ea42"
   },
   "outputs": [],
   "source": [
    "fig, ax = plt.subplots(figsize = (10,8))\n",
    "sns.barplot(x= 'rating', y = 'name', data= top_restaurants, ax = ax, palette = 'viridis')\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "bn0MCck0yem3"
   },
   "source": [
    "Award\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/",
     "height": 331
    },
    "id": "txPjwMiGNe9x",
    "outputId": "566b9c92-a8bc-4311-f245-b8b5d9ded0f8"
   },
   "outputs": [],
   "source": [
    "filtered = resturant_data[resturant_data['awardType'] == 'COE']\n",
    "\n",
    "# Select only the relevant columns\n",
    "result = filtered[['name', 'awardType', 'year']]\n",
    "result"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "KdwYyMrvzySp"
   },
   "source": [
    "Check the number of premium restaurant"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/",
     "height": 685
    },
    "id": "4Mj8iZ7e0DW8",
    "outputId": "cf36184d-3f61-455f-ab10-b7e3d50cd0bc"
   },
   "outputs": [],
   "source": [
    "plt.figure(figsize=(15, 6))\n",
    "sns.countplot(x='isPremium', data=resturant_data, palette='viridis', width=0.3)\n",
    "plt.title('Number of Premium resturant')\n",
    "plt.xlabel('Premium')\n",
    "plt.ylabel('Count')\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/",
     "height": 178
    },
    "id": "j8qAAsj305Rj",
    "outputId": "82fce19c-1b9c-4003-b623-aa741a517ad6"
   },
   "outputs": [],
   "source": [
    "resturant_data['isPremium'].value_counts()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "buIb5sUe55EM"
   },
   "source": [
    "Create a new columns combined cuisines"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "id": "TipxAVs25tzl"
   },
   "outputs": [],
   "source": [
    "# List of cuisine columns that exist in the DataFrame\n",
    "cuisine_cols = ['cuisine1']\n",
    "\n",
    "# Combine non-empty cuisine values into a single column\n",
    "resturant_data['combined_cuisines'] = resturant_data[cuisine_cols].apply(\n",
    "    lambda row: ', '.join([str(val) for val in row if pd.notna(val) and str(val).strip() != '']),\n",
    "    axis=1\n",
    ")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "id": "7M3O5Slj6Ztt"
   },
   "outputs": [],
   "source": [
    "cuisine_data = resturant_data[resturant_data['combined_cuisines'].str.strip().astype(bool)]\n",
    "\n",
    "# Drop rows where 'combined_cuisines' is an empty string after stripping whitespace\n",
    "cuisine_data = cuisine_data[cuisine_data['combined_cuisines'] != '']"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "id": "HQJlW2q59EAP"
   },
   "outputs": [],
   "source": [
    "cuisine_data['cuisine_count'] = cuisine_data['combined_cuisines'].apply(\n",
    "    lambda x: len(x.split(', ')) if x else 0\n",
    ")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "Gb6et-qe-8h7"
   },
   "source": [
    "Plot the number of cuisines"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/",
     "height": 147
    },
    "id": "Kd4fTKqB_XQH",
    "outputId": "2f53cb59-73fc-4167-a80b-d96b26cccd9b"
   },
   "outputs": [],
   "source": [
    "cuisine_data['cuisine_count'].value_counts()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/",
     "height": 829
    },
    "id": "Qt0mvetJCJXA",
    "outputId": "debd2e83-690c-4aa4-b62b-ff2ebe7d6857"
   },
   "outputs": [],
   "source": [
    "# Split the 'combined_cuisines' string into individual cuisines\n",
    "all_cuisines = cuisine_data['combined_cuisines'].str.split(', ').explode()\n",
    "\n",
    "# Count the occurrences of each cuisine\n",
    "cuisine_counts = all_cuisines.value_counts()\n",
    "\n",
    "# Select the top N cuisines to display, and group the rest as 'Other'\n",
    "top_n = 15\n",
    "other_count = cuisine_counts[top_n:].sum()\n",
    "top_cuisines = cuisine_counts[:top_n]\n",
    "\n",
    "if other_count > 0:\n",
    "    top_cuisines['Other'] = other_count\n",
    "\n",
    "# Create the pie chart\n",
    "plt.figure(figsize=(10, 10))\n",
    "plt.pie(top_cuisines, labels=top_cuisines.index, autopct='%1.1f%%', startangle=90, colors=sns.color_palette('viridis', len(top_cuisines)))\n",
    "plt.title('Distribution of Cuisines')\n",
    "plt.axis('equal') # Equal aspect ratio ensures that pie is drawn as a circle.\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "9M1PsPv6A2I1"
   },
   "source": [
    "Top 10 resturant with higest review count"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/",
     "height": 363
    },
    "id": "XGlma-6vA6az",
    "outputId": "f5e20966-ad08-4013-ca7a-1040161561b0"
   },
   "outputs": [],
   "source": [
    "top_10 = resturant_data[['name', 'reviewCount']].sort_values(by='reviewCount', ascending=False).head(10)\n",
    "top_10"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/",
     "height": 839
    },
    "id": "qpBYlxxKBghy",
    "outputId": "611e2e56-6b00-4d4b-9415-dbee368ef3b4"
   },
   "outputs": [],
   "source": [
    "\n",
    "plt.figure(figsize=(12, 8))\n",
    "sns.barplot(x='reviewCount', y='name', data=top_10, palette='viridis')\n",
    "plt.title('Top 10 Restaurants by Review Count')\n",
    "plt.xlabel('Review Count')\n",
    "plt.ylabel('Restaurant Name')\n",
    "plt.show()\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/"
    },
    "id": "8GVbXB1eXnBV",
    "outputId": "0ab7b1cd-c280-471a-8e88-53c532bc5fd1"
   },
   "outputs": [],
   "source": [
    "!apt install gdal-bin python-gdal python3-gdal\n",
    "!apt install python3-rtree\n",
    "\n",
    "!pip install git+git://github.com/geopandas/geopandas.git\n",
    "!pip install descartes\n",
    "!pip install folium\n",
    "!pip install plotly_express"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "id": "3VVKlNGjX-S5"
   },
   "outputs": [],
   "source": [
    "import pandas as pd\n",
    "import numpy as np\n",
    "import geopandas as gpd\n",
    "\n",
    "import matplotlib.pyplot as plt\n",
    "import seaborn as sns\n",
    "\n",
    "import folium\n",
    "\n",
    "import plotly\n",
    "import plotly.offline as py\n",
    "import plotly.graph_objs as go\n",
    "import plotly_express as px\n",
    "\n",
    "from sklearn.cluster import KMeans\n",
    "from sklearn.metrics import silhouette_score"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "id": "CmDc1QhId7oW"
   },
   "outputs": [],
   "source": [
    "# Filter data within Kandy town bounding box\n",
    "kandy_town_data = resturant_data[\n",
    "    (resturant_data['latitude'] >= 7.2750) & (resturant_data['latitude'] <= 7.3100) &\n",
    "    (resturant_data['longitude'] >= 80.6100) & (resturant_data['longitude'] <= 80.6600)\n",
    "]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/",
     "height": 817
    },
    "id": "mti-0cq6Y5rW",
    "outputId": "a8807ab8-255e-4fbe-b82e-e2dc84b17d76"
   },
   "outputs": [],
   "source": [
    "import plotly.express as px\n",
    "\n",
    "fig = px.scatter_mapbox(\n",
    "    kandy_town_data,\n",
    "    lat=\"latitude\",\n",
    "    lon=\"longitude\",\n",
    "    color=\"rating\",\n",
    "    size=\"reviewCount\",\n",
    "    size_max=30,\n",
    "    zoom=15,\n",
    "    center={\"lat\": 7.2906, \"lon\": 80.6337},\n",
    "    mapbox_style='carto-positron',\n",
    "    hover_name=\"name\",  # Show restaurant name on hover\n",
    "    width=1000,\n",
    "    height=800\n",
    ")\n",
    "fig.show()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "izp2XGiXgcFj"
   },
   "source": [
    "# Determine the number of clusters(K)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/",
     "height": 487
    },
    "id": "Yo3qhSK6gbup",
    "outputId": "e25f57e0-63d9-485b-e149-8fcf6e8c6d3a"
   },
   "outputs": [],
   "source": [
    "coords = resturant_data[['latitude', 'longitude']].dropna()\n",
    "\n",
    "from sklearn.cluster import KMeans\n",
    "from sklearn.metrics import silhouette_score\n",
    "import matplotlib.pyplot as plt\n",
    "\n",
    "# Drop NaNs from coordinate columns\n",
    "coords = resturant_data[['latitude', 'longitude']].dropna()\n",
    "\n",
    "distortions = []  # initialize before loop\n",
    "K = range(2, 11)\n",
    "\n",
    "for k in K:\n",
    "    kmeansModel = KMeans(n_clusters=k)\n",
    "    kmeansModel = kmeansModel.fit(coords)\n",
    "    distortions.append(kmeansModel.inertia_)\n",
    "\n",
    "# Plot elbow curve\n",
    "plt.figure(figsize=(8, 5))\n",
    "plt.plot(K, distortions, 'bx-')\n",
    "plt.xlabel('Number of clusters (k)')\n",
    "plt.ylabel('Distortion (Inertia)')\n",
    "plt.title('Elbow Method For Optimal k')\n",
    "plt.show()\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "6QNiM_3akA3k"
   },
   "source": [
    "Silhoute Method"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "id": "dsJEx6YwkGyJ"
   },
   "outputs": [],
   "source": [
    "from sklearn.metrics import silhouette_score\n",
    "\n",
    "sil = []\n",
    "kmax = 50\n",
    "\n",
    "for k in range(2, kmax+1):\n",
    "    kmeans = KMeans(n_clusters=k).fit(coords)\n",
    "    labels = kmeans.labels_\n",
    "    sil_avg = silhouette_score(coords, labels)\n",
    "    sil.append(sil_avg)\n",
    "    kmeans.fit(coords)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/"
    },
    "id": "ni9VhlXskW_5",
    "outputId": "23bef20c-3323-4f6c-d481-62c55e4911b1"
   },
   "outputs": [],
   "source": [
    "sil"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "me2aFp9CiXfH"
   },
   "source": []
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "zbYGXCafipim"
   },
   "source": [
    "# K-Means Clustering"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/"
    },
    "id": "NcNhU6b4io35",
    "outputId": "553ca894-5653-4905-93a6-726c76c5e3fc"
   },
   "outputs": [],
   "source": [
    "kmeans = KMeans(n_clusters=5, init='k-means++')\n",
    "kmeans.fit(coords)\n",
    "y = kmeans.labels_\n",
    "print('k=5', 'Silhouette Score:', silhouette_score(coords, y, metric='euclidean'))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/",
     "height": 469
    },
    "id": "B_StnKyejDx5",
    "outputId": "f2c8ab1f-783f-46ab-a15f-bb6f0b67a4ec"
   },
   "outputs": [],
   "source": [
    "# 1. Prepare the data for prediction - drop NaNs\n",
    "coords_no_nan = resturant_data[['latitude', 'longitude']].dropna()\n",
    "\n",
    "# 2. Predict clusters on clean data\n",
    "clusters = kmeans.predict(coords_no_nan)\n",
    "\n",
    "# 3. Assign clusters back only to the rows without NaNs\n",
    "resturant_data.loc[coords_no_nan.index, 'cluster'] = clusters\n",
    "\n",
    "# 4. Check result\n",
    "resturant_data.head()\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/",
     "height": 817
    },
    "id": "48RD8l10lfS7",
    "outputId": "43c95706-572d-4fb2-e8b9-3988debc988a"
   },
   "outputs": [],
   "source": [
    "px.scatter_mapbox(\n",
    "    resturant_data,\n",
    "    lat=\"latitude\",\n",
    "    lon=\"longitude\",\n",
    "    color=\"cluster\",\n",
    "    zoom=14,\n",
    "    center={\"lat\": 7.2906, \"lon\": 80.6337},\n",
    "    mapbox_style='carto-positron',\n",
    "    width=1000,\n",
    "    height=800\n",
    ")\n",
    "\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "_X6Cu6w2mg8u"
   },
   "source": [
    "# Location Based Recommendation"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/",
     "height": 538
    },
    "id": "ERz375Bumc9N",
    "outputId": "6e356fcc-5114-4a2c-8a09-f9d9b6b85236"
   },
   "outputs": [],
   "source": [
    "top_restaurants_Kandy = resturant_data.sort_values(by = ['rating', 'reviewCount'], ascending = False)\n",
    "top_restaurants_Kandy.head()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "Q_qMxM3MqPI-"
   },
   "source": []
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "lPoa2-h_qRsV"
   },
   "source": [
    "Get top 5 recommended restaurents in kandy"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/",
     "height": 293
    },
    "id": "eIGgQg1gmu-K",
    "outputId": "51722f84-f161-47e6-c082-ffda23de69dc"
   },
   "outputs": [],
   "source": [
    "import numpy as np\n",
    "\n",
    "def recommend_restaurants(resturant_data, longitude=80.6337, latitude=7.2906, top_n=5):\n",
    "    # Predict cluster for the given coordinates\n",
    "    cluster = kmeans.predict(np.array([longitude, latitude]).reshape(1, -1))[0]\n",
    "    print(f\"Predicted cluster: {cluster}\")\n",
    "\n",
    "    # Restaurants in predicted cluster\n",
    "    cluster_restaurants = resturant_data[resturant_data['cluster'] == cluster]\n",
    "    cluster_restaurants = cluster_restaurants.sort_values(by='rating', ascending=False)\n",
    "\n",
    "    # If less than top_n, add more from the full dataset (excluding duplicates)\n",
    "    if len(cluster_restaurants) < top_n:\n",
    "        needed = top_n - len(cluster_restaurants)\n",
    "        fallback = resturant_data[~resturant_data.index.isin(cluster_restaurants.index)]\n",
    "        fallback = fallback.sort_values(by='rating', ascending=False).head(needed)\n",
    "        recommendations = pd.concat([cluster_restaurants, fallback]) # Changed from append to concat\n",
    "    else:\n",
    "        recommendations = cluster_restaurants.head(top_n)\n",
    "\n",
    "    return recommendations[['name', 'latitude', 'longitude']]\n",
    "\n",
    "# Example usage\n",
    "recommend_restaurants(top_restaurants_Kandy)\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "Ow2BjduCqJfQ"
   },
   "source": [
    "Get top 10 recommended restaurents in kandy"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/",
     "height": 380
    },
    "id": "9j8KENJspks-",
    "outputId": "e2178b3a-3bb4-4986-f89d-c656cecf9898"
   },
   "outputs": [],
   "source": [
    "import numpy as np\n",
    "import pandas as pd\n",
    "\n",
    "def recommend_restaurants(resturant_data, longitude=80.6337, latitude=7.2906, top_n=10):\n",
    "    # Predict cluster for the given coordinates (Kandy center by default)\n",
    "    cluster = kmeans.predict(np.array([longitude, latitude]).reshape(1, -1))[0]\n",
    "    print(f\"Predicted cluster: {cluster}\")\n",
    "\n",
    "    # Restaurants in predicted cluster\n",
    "    cluster_restaurants = resturant_data[resturant_data['cluster'] == cluster]\n",
    "    cluster_restaurants = cluster_restaurants.sort_values(by='rating', ascending=False)\n",
    "\n",
    "    # If fewer than top_n, add top-rated restaurants from other clusters\n",
    "    if len(cluster_restaurants) < top_n:\n",
    "        needed = top_n - len(cluster_restaurants)\n",
    "        fallback = resturant_data[~resturant_data.index.isin(cluster_restaurants.index)]\n",
    "        fallback = fallback.sort_values(by='rating', ascending=False).head(needed)\n",
    "        recommendations = pd.concat([cluster_restaurants, fallback])\n",
    "    else:\n",
    "        recommendations = cluster_restaurants.head(top_n)\n",
    "\n",
    "    return recommendations[['name', 'latitude', 'longitude']]\n",
    "\n",
    "# Example usage\n",
    "recommend_restaurants(top_restaurants_Kandy)\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "ehMNuV7Atntx"
   },
   "source": [
    "# **Application**"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/",
     "height": 1000,
     "referenced_widgets": [
      "4950de79ef784c29b6fcb4d2e90e084c",
      "f725ecb06b47464ca49a8b214a8ff950",
      "e9611dc7f8d345a69e583928b850e386",
      "9559ae33e22940d1a6f6a3fcb7fca35f",
      "b8f413ea7e3244fd81585fb53e18a74c"
     ]
    },
    "id": "8cg8nls5255b",
    "outputId": "8d3a110a-f8af-4d1e-dd30-320a9e855673"
   },
   "outputs": [],
   "source": [
    "import ipywidgets as widgets\n",
    "from IPython.display import display, clear_output\n",
    "import pandas as pd\n",
    "import folium\n",
    "from IPython.display import HTML\n",
    "\n",
    "\n",
    "resturant_review_data = pd.read_csv('/content/sample_data/Rest_review - Sheet1 (1).csv')\n",
    "resturant_review_data.head()\n",
    "\n",
    "# First, create a new merged review column if you haven't already\n",
    "resturant_review_data['combined_review'] = resturant_review_data[['review1', 'review2']].fillna('').agg(' '.join, axis=1)\n",
    "\n",
    "# Dropdown\n",
    "dropdown = widgets.Dropdown(\n",
    "    options=resturant_review_data['name'].dropna().unique(),\n",
    "    description='Restaurant:',\n",
    "    layout=widgets.Layout(width='50%')\n",
    ")\n",
    "\n",
    "output = widgets.Output()\n",
    "\n",
    "def show_reviews(change):\n",
    "    with output:\n",
    "        clear_output(wait=True)\n",
    "\n",
    "        selected = change['new']\n",
    "        info = resturant_review_data[resturant_review_data['name'] == selected]\n",
    "        display(info[['name', 'rating', 'latitude', 'longitude', 'combined_review']])\n",
    "\n",
    "        # Get lat/lon\n",
    "        lat = info['latitude'].values[0]\n",
    "        lon = info['longitude'].values[0]\n",
    "\n",
    "         # Add vertical space\n",
    "        display(HTML(\"<div style='margin-top: 50px;'></div>\"))  # 20px vertical space\n",
    "\n",
    "        # Create and display map\n",
    "        m = folium.Map(location=[lat, lon], zoom_start=16)\n",
    "        folium.Marker([lat, lon], popup=selected).add_to(m)\n",
    "        display(m)\n",
    "\n",
    "dropdown.observe(show_reviews, names='value')\n",
    "\n",
    "display(dropdown, output)\n"
   ]
  }
 ],
 "metadata": {
  "colab": {
   "provenance": []
  },
  "kernelspec": {
   "display_name": "Python 3",
   "name": "python3"
  },
  "language_info": {
   "name": "python"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 0
}